Collection
  - 데이터의 집합이다.
  - Collection의 인터페이스는 List, Set, Map으로 분류된다.
  - Array와는 달리, 길이를 미리 정의해 줄 필요가 없으며, 객체를 요소로 하기 때문에 타입이 다른 복수의 데이터를 저장할 수 있다.

● Set
  - 순서를 유지하지 않는 데이터의 집합으로, 데이터의 중복을 허용하지 않는다.
  - HashSet
    ■ 임의 접근 속도가 가장 빠르다.
  - TreeSet
    ■ 트리 구조를 기반으로 하며, 첫 번째로 입력되는 데이터가 root가 된다. 
    ■ 트리 구조: root 다음으로 입력되는 데이터는 root와 값을 비교하여 오름차순으로 정렬되고, 그 다음 데이터는 root, 두 번째로 들어온 데이터와 값을 비교하여 다시 오름차순으로 정렬한다. 이를 반복하는 것을 트리 구조라고 한다.
  
● List
  - 순서(index)가 있는 데이터의 집합으로, 데이터의 중복을 허용한다.
  - Vector
    ■ 용량이 부족하면 현재 벡터가 차지하고 있는 용량만큼의 추가 공간을 확보한다.
    ■ 자동으로 동기화되기 때문에, 스레드 안전 구현을 위한 경우를 제외하면, ArrayList를 사용하는 것이 좋다.
  - ArrayList
    ■ 동기화가 되지 않는다.
    ■ 단방향 포인터 구조로, 데이터 조회 성능은 뛰어나지만, 삽입, 삭제에는 비효율적이다.
    ■ 데이터를 삽입, 삭제하면 해당 데이터 뒤의 모든 데이터가 움직여야 하므로 비효율적이다.
  - LinkedList 
    ■ 양방향 포인터 구조로, 데이터의 삽입, 삭제가 빈번할 경우 유용하다.
    ■ 각 요소들은 데이터와 다음 데이터를 가리키는 주소로 이루어져 있는데, 이를 Node라고 한다. 
    ■ 데이터를 삽입, 삭제할 때는 해당 데이터의 앞, 뒤 데이터의 주소만 바꿔주면 되기 때문에 삽입, 삭제에는 유리하지만, 데이터를 검색하기 위해서는 모든 주소를 뒤져야 하므로 비효율적이다.

● Map
  - {Key: Value}의 쌍으로 이루어진 데이터의 집합으로 순서를 유지하지 않는다.
  - Key는 중복이 허용되지 않으나 Value의 중복은 허용된다.
  
● Methods
  - 대체로 공통적으로 사용할 수 있는 메소드들이다. 컬렉션의 종류에 따라 사용하지 못하는 경우도 있다.
  - add(E): 컬렉션에 순서대로 데이터를 추가한다.
  - addElement(E): 컬렉션에 순서대로 데이터를 추가하되, 컬렉션의 크기를 하나 키운다.
  - add(index, E): 원하는 인덱스에 데이터를 추가하고, 원래 있던 데이터들은 한 칸씩 뒤로 미룬다.
  - clear(): 컬렉션을 비운다.
  - clone(): 컬렉션을 복제한다.
  - firstElement(): 컬렉션의 첫 번째 엘리먼트(index 0)를 가져온다.
  - isEmpty(): 컬렉션이 비어있는지를 확인한다.
  - insertElement(E, index): 컬렉션에 해당 위치에 요소를 추가한다.
  - lastElement(): 컬렉션의 마지막 요소를 반환한다.
  - remove(index): 컬렉션에서 해당 위치의 요소를 삭제한다.
  - remove(E): 컬렉션에서 해당 요소를 삭제한다.
  - removeElement(E): 컬렉션에서 해당 요소를 삭제한다.
  - removeElementAt(index): 컬렉션에서 해당 위치의 요소를 삭제한다.
  - removeRange(n, m): 컬렉션의 요소 중 인덱스 n 이상 m 미만의 요소를 삭제한다.
  - toArray(): 컬렉션을 배열로 만들어 반환한다.
  - toString(): 컬렉션을 문자열로 만들어 반환한다.
  - size(): 컬렉션의 길이를 반환한다.
