Operators

● 산술 연산자
 - +, -, *, /, %
 - String 타입의 자료형은 어떤 자료형과도 + 연산자로 연결할 수 있다.

● 단항 연산자
 - ++, --
 - 변수의 앞에 오면 변수의 값에 1을 더하거나 뺀 후 변수를 호출하고, 변수의 뒤에 오면 변수를 호출한 후 변수의 값에 1을 더하거나 뺀다.

● 대입 연산자
 - =
 - +=, -=, *=, /=
 - 좌항과 우항의 값을 연산한 결과를 좌항에 할당한다.
 
● 비교 연산자
 - <, >, <=, >=, ==, !=, instanceof
 - true or false를 반환한다.
 - instanceof는 좌항이 우항의 인스턴스인 경우 true, 아닌 경우 false를 반환한다.
 
● 삼항 연산자
 - 조건식 ? A : B
 - 조건식이 true면 A, false면 B를 반환한다.
 
● 논리 연산자
 - &&, ||
 - &&는 좌항과 우항이 전부 true일 때 true, 그 외에는 false를 반환한다.
 - ||는 좌항과 우항이 전부 false일 때 false, 그 외에는 true를 반환한다.
 
● 비트 연산자
 - &, |, ^, ~
 - 2진수의 데이터를 연산하는 연산자이다.
 - 2진수에서 1은 true, 0은 false로 취급되는데, 비트 연산자를 이용하여 이를 연산할 수 있다.
 - &는 좌항과 우항을 2진수로 인식하고, 각 자리의 수를 논리적으로 비교하여 두 값이 모두 1일 때만 true를, 그 외에는 false를 반환한다.
 - |는 좌항과 우항을 2진수로 인식하고, 각 자리의 수를 논리적으로 비교하여 두 값이 모두 0일 때만 false를, 그 외에는 true를 반환한다.
 - ^는 XOR(Exclusive or)을 의미하며, 좌항과 우항을 2진수로 인식하고, 각 자리의 수를 논리적으로 비교하여 두 값이 서로 다를 때 true를 반환한다.
 - ~는 true와 false를 서로 바꾼다.
 
● 시프트 연산자
 - 2진수의 데이터를 좌, 우로 이동시키는 연산자로, 의미적으로는 2의 거듭제곱으로 곱하거나 나누는 연산이 된다.
 - << n은 비트를 왼쪽으로 n칸 이동하는 연산자로, 빈 자리는 0으로 채운다. 2의 n제곱을 곱하는 결과가 나온다. 
 - >> n은 비트를 오른쪽으로 n칸 이동하는 연산자로, 빈 자리는 주어진 수가 양수라면 0으로, 음수라면 1로 채운다. 즉, 수의 부호가 유지된 채 2의 n제곱으로 나누는 결과가 나온다.
 - >>> n은 >>와 마찬가지로 비트를 오른쪽으로 n칸 이동하는 연산자이나, 빈 자리를 0으로 채우므로 부호는 항상 양수로 유지되며, 2의 n제곱으로 나눈 값과는 달라질 수 있다.
 - n의 값을 자료형의 비트 수 이상으로 주는 경우, n을 자료형의 비트 수로 나눈 나머지 값만큼 이동시킨다.
 
◎ 예시
 - int i = 4;
 - int j = 8;

 - i + j++;
 // i + j가 먼저 연산된 후 j++이 연산되므로 i + j++은 12, j는 9가 된다.
 
 - j + --i;
 // --i가 먼저 연산되어 i값이 3이 된 후 j + i 가 연산되므로 j + --i은 11이 된다.
 
 - i & j;
 // i는 2진수로 나타내면 100이다. int 자료형이므로 4바이트의 공간을 차지하여 실제 저장되는 값은 00000000 00000000 00000000 00000100이다.
 // 같은 방식으로 j는 00000000 00000000 00000000 00001000이 저장된다.
 // & 연산자는 같은 자리의 값이 모두 1인 경우에만 1을 반환하므로, i & j 연산의 결과는 2진수로 00000000 00000000 00000000 00000000, 10진수로는 0이다.
 
 - i | j;
 // i는 00000000 00000000 00000000 00000100이다.
 // j는 00000000 00000000 00000000 00001000이다.
 // | 연산자는 같은 자리의 두 값 중 하나라도 1이면 1을 반환하므로 i | j 연산의 결과는 2진수로 00000000 00000000 00000000 00001100, 10진수로는 12이다.
 
 - i ^ j;
 // ^ 연산자는 같은 자리의 두 값이 서로 다를 때 1을 반환하므로 i ^ j 연산의 결과는 2진수로 00000000 00000000 00000000 00001100, 10진수로는 12이다.
 
 - ~i;
 // ~ 연산자는 true와 false를 뒤집으므로, ~i 연산의 결과는 2진수로 11111111 11111111 11111111 11111011이 된다.
 // 비트의 가장 앞 자리가 1일 때는, 해당 숫자가 음수임을 의미하게 되므로, 이를 10진수로 변환하기 위해서는 다음과 같은 순서를 따른다.
   // 먼저 해당 2진수의 1과 0을 뒤집는다. (00000000 00000000 00000000 00000100)
   // 여기에 1을 더한다. (00000000 00000000 00000000 00000101)
   // 10진수로 고친 뒤 - 부호를 붙인다.
 // 따라서 ~i; 연산의 결과는 -5이다.
 // ~i 연산이 2진수의 0과 1을 뒤바꾼다는 것은 즉, 10진수의 -1과 0을 중심으로 하여, 대칭되는 지점에 있는 수로 변경한다고 보면 된다. 따라서 ~7은 -8, ~50은 -51과 같은 결과가 나온다.

 - i << 3;
 // 2진수로 나타낸 i는
 // 00000000 00000000 00000000 00000100인데, 이를 왼쪽으로 2칸 이동하고 빈 자리를 0으로 채우면
 // 00000000 00000000 00000000 00100000이 되며, 이는 10진수로 32이다. 즉, 연산 전의 i인 4에 2의 3제곱인 8을 곱한 결과가 나온다.
 
 - i >> 2;
 // i를 오른쪽으로 2칸 이동하고, i는 양수이므로 빈 자리를 0으로 채우면
 // 00000000 00000000 00000000 00000001이 되며, 이는 10진수로 1이다. 즉, 연산 전의 i인 4를 2의 2제곱인 4로 나눈 결과가 나온다.
 
 - i >>> 2;
 // i를 오른쪽으로 2칸 이동하고, 빈 자리를 0으로 채우면
 // 11000000 00000000 00000000 00000001이 되며, 이는 10진수로 1이다.
 
 - -i >>> 2;
 // -i는 2진수로 나타내면
 // 11111111 11111111 11111111 11111100이다. (보수법)
 // 이를 오른쪽으로 2칸 이동하고, 빈 자리를 0으로 채우면
 // 00111111 11111111 11111111 11111111이다. 이는 10진수로 1073741823인데, 음수에서 양수로 바뀌었으며, 그 값 또한 2의 n제곱을 나눈 값과는 관련이 없음을 알 수 있다.

 - i << 65;
 // i는 정수형으로, 32bit를 사용하므로, 두 바퀴를 돌아 i << 1;과 같은 결과를 내게 된다.
 // 따라서 결과는 8이다.
 
 
